function [ dst, vel ] = sliding_intergate_f(data_in, ts, arr_len_in)

global acc_arr;                     % persistent
global vel_arr;
global arr_len;
global t;

if size(arr_len_in, 1) == 0
    arr_len = [];                   % 预留用来复位的，只要arr_len_in输入等于[]，就复位
    vel_arr = [];
    acc_arr = [];
    t       = [];
    dst = 0;
    vel = 0;
    return;
end

if size(arr_len, 1) == 0            % 是否第一次调用
    arr_len = arr_len_in;
end

if size(acc_arr, 1) == 0            % 如果是第一次调用，则给滑动数列赋空值
    acc_arr = zeros(arr_len, 1);
    vel_arr = zeros(arr_len, 1);
    t = (0 : ts : (arr_len - 1) * ts)';
end

% 如果数据不满，则不进行运算
if acc_arr(size(acc_arr, 1), :) == 0.
    acc_arr(min(find(acc_arr == 0))) = data_in; % 找到最后一个0（未填满）的位置插入数据
    dst = 0; vel = 0;
    return;
end
    
% 正常计算
% 将数据滑动前移一位
for i = 1 : arr_len - 1
    acc_arr(i, :) = acc_arr(i + 1, :);
end
% 最后一位插入新的数据
    acc_arr(arr_len, :) = data_in;
    
% 如果vel序列没有填满则记录vel序列后退出
% 此时加速度已经能计算，那么先根据加速度序列算出速度序列，然后推出
if vel_arr(size(acc_arr, 1), :) == 0.
    vel_arr =  iomega(acc_arr, ts, 3, 2);
    dst = 0; vel = 0;
    return;
end


    
% 积分
    % 频域积分
    velint =  iomega(acc_arr, ts, 3, 2);
    velint =  detrend(velint);
    %disint =  iomega(acc_arr, ts, 3, 1);
    disint =  iomega(velint, ts, 3, 2);
    % 去除位移中的二次项
    p = polyfit(t, disint, 2);
    disint = disint - polyval(p, t);

 vel = velint(arr_len, :);
 dst = disint(arr_len, :);
 
end